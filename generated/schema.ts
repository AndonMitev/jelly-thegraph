// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class NewContract extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save NewContract entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save NewContract entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("NewContract", id.toString(), this);
  }

  static load(id: string): NewContract | null {
    return store.get("NewContract", id) as NewContract | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get inputAmount(): BigInt {
    let value = this.get("inputAmount");
    return value.toBigInt();
  }

  set inputAmount(value: BigInt) {
    this.set("inputAmount", Value.fromBigInt(value));
  }

  get outputAmount(): BigInt {
    let value = this.get("outputAmount");
    return value.toBigInt();
  }

  set outputAmount(value: BigInt) {
    this.set("outputAmount", Value.fromBigInt(value));
  }

  get expiration(): BigInt {
    let value = this.get("expiration");
    return value.toBigInt();
  }

  set expiration(value: BigInt) {
    this.set("expiration", Value.fromBigInt(value));
  }

  get contractId(): Bytes {
    let value = this.get("contractId");
    return value.toBytes();
  }

  set contractId(value: Bytes) {
    this.set("contractId", Value.fromBytes(value));
  }

  get hashLock(): Bytes {
    let value = this.get("hashLock");
    return value.toBytes();
  }

  set hashLock(value: Bytes) {
    this.set("hashLock", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    return value.toBytes();
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }

  get outputNetwork(): string {
    let value = this.get("outputNetwork");
    return value.toString();
  }

  set outputNetwork(value: string) {
    this.set("outputNetwork", Value.fromString(value));
  }

  get outputAddress(): string {
    let value = this.get("outputAddress");
    return value.toString();
  }

  set outputAddress(value: string) {
    this.set("outputAddress", Value.fromString(value));
  }
}

export class NewContractSender extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save NewContractSender entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save NewContractSender entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("NewContractSender", id.toString(), this);
  }

  static load(id: string): NewContractSender | null {
    return store.get("NewContractSender", id) as NewContractSender | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get swaps(): Array<string> {
    let value = this.get("swaps");
    return value.toStringArray();
  }

  set swaps(value: Array<string>) {
    this.set("swaps", Value.fromStringArray(value));
  }
}

export class NewContractReceiver extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save NewContractReceiver entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save NewContractReceiver entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("NewContractReceiver", id.toString(), this);
  }

  static load(id: string): NewContractReceiver | null {
    return store.get("NewContractReceiver", id) as NewContractReceiver | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get swaps(): Array<string> {
    let value = this.get("swaps");
    return value.toStringArray();
  }

  set swaps(value: Array<string>) {
    this.set("swaps", Value.fromStringArray(value));
  }
}

export class Withdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Withdraw entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Withdraw entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Withdraw", id.toString(), this);
  }

  static load(id: string): Withdraw | null {
    return store.get("Withdraw", id) as Withdraw | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get withdrawId(): Bytes {
    let value = this.get("withdrawId");
    return value.toBytes();
  }

  set withdrawId(value: Bytes) {
    this.set("withdrawId", Value.fromBytes(value));
  }

  get secret(): Bytes {
    let value = this.get("secret");
    return value.toBytes();
  }

  set secret(value: Bytes) {
    this.set("secret", Value.fromBytes(value));
  }

  get hashLock(): Bytes {
    let value = this.get("hashLock");
    return value.toBytes();
  }

  set hashLock(value: Bytes) {
    this.set("hashLock", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    return value.toBytes();
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }
}

export class WithdrawSender extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save WithdrawSender entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save WithdrawSender entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("WithdrawSender", id.toString(), this);
  }

  static load(id: string): WithdrawSender | null {
    return store.get("WithdrawSender", id) as WithdrawSender | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get withdraws(): Array<string> {
    let value = this.get("withdraws");
    return value.toStringArray();
  }

  set withdraws(value: Array<string>) {
    this.set("withdraws", Value.fromStringArray(value));
  }
}

export class WithdrawReceiver extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save WithdrawReceiver entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save WithdrawReceiver entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("WithdrawReceiver", id.toString(), this);
  }

  static load(id: string): WithdrawReceiver | null {
    return store.get("WithdrawReceiver", id) as WithdrawReceiver | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get withdraws(): Array<string> {
    let value = this.get("withdraws");
    return value.toStringArray();
  }

  set withdraws(value: Array<string>) {
    this.set("withdraws", Value.fromStringArray(value));
  }
}

export class Refund extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Refund entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Refund entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Refund", id.toString(), this);
  }

  static load(id: string): Refund | null {
    return store.get("Refund", id) as Refund | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get refundId(): Bytes {
    let value = this.get("refundId");
    return value.toBytes();
  }

  set refundId(value: Bytes) {
    this.set("refundId", Value.fromBytes(value));
  }

  get hashLock(): Bytes {
    let value = this.get("hashLock");
    return value.toBytes();
  }

  set hashLock(value: Bytes) {
    this.set("hashLock", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    return value.toBytes();
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }
}

export class RefundSender extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save RefundSender entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RefundSender entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RefundSender", id.toString(), this);
  }

  static load(id: string): RefundSender | null {
    return store.get("RefundSender", id) as RefundSender | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get refunds(): Array<string> {
    let value = this.get("refunds");
    return value.toStringArray();
  }

  set refunds(value: Array<string>) {
    this.set("refunds", Value.fromStringArray(value));
  }
}

export class RefundReceiver extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save RefundReceiver entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RefundReceiver entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RefundReceiver", id.toString(), this);
  }

  static load(id: string): RefundReceiver | null {
    return store.get("RefundReceiver", id) as RefundReceiver | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get refunds(): Array<string> {
    let value = this.get("refunds");
    return value.toStringArray();
  }

  set refunds(value: Array<string>) {
    this.set("refunds", Value.fromStringArray(value));
  }
}
